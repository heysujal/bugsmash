import { updateJob } from "./jobStore";
import { execa } from "execa";
import { runClineDryRun } from "./cline";
import fs from "fs";

export async function runJob(jobId: string, repoUrl: string) {
  const workdir = `/tmp/bughunter-${jobId}`;

  try {
    updateJob(jobId, j => {
      j.status = "cloning";
      j.logs.push("Cloning repository...");
    });

    await execa("git", ["clone", repoUrl, workdir]);

    updateJob(jobId, j => {
      j.status = "linting";
      j.logs.push("Installing dependencies...");
    });

    updateJob(jobId, j => {
      j.logs.push("Running ESLint...");
    });

await execa(
  "npm",
  ["run", "lint", "--", "-f", "json", "-o", "/tmp/lint.json"],
  { cwd: workdir, reject: false }
);

        

    const lintPath = "/tmp/lint.json";
    if (fs.existsSync(lintPath)) {
      const size = fs.statSync(lintPath).size;
      updateJob(jobId, j => {
        j.logs.push(`lint.json generated (${size} bytes)`);
      });
    } else {
      updateJob(jobId, j => {
        j.logs.push("ESLint did not generate lint.json");
      });
    }

    updateJob(jobId, j => {
      j.status = "done";
      j.logs.push("Lint completed");
    });

    updateJob(jobId, j => {
        j.logs.push("Running Cline (dry-run)...");
    });

    const clineOutput = await runClineDryRun(workdir);

    updateJob(jobId, j => {
    j.logs.push("Cline summary:");
    j.logs.push(clineOutput);
    j.logs.push("Patch written to /tmp/proposed_patch.diff");
    });

 
    

const patchPath = "/tmp/proposed_patch.diff";

if (fs.existsSync(patchPath)) {
    const patch = fs.readFileSync(patchPath, "utf8");
    updateJob(jobId, j => {
        j.patch = patch;
        j.logs.push("Patch preview:");
        j.logs.push(patch.slice(0, 500)); // first 500 chars
    });
    } else {
        updateJob(jobId, j => {
            j.logs.push("No patch generated by Cline");
        });
    }

  } catch (err: any) {
    updateJob(jobId, j => {
      j.status = "failed";
      j.logs.push("Error: " + err.message);
    });
  }
}
